function labels = vesicle_detect(em, template, min_cluster_size, tail, overlap_percentage,...
        cluster_dist_multiplier,cluster_cost,alpha,beta)
    %VESICLE_DETECT basic correlation based vesicle detector
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Â© [2014] The Johns Hopkins University / Applied Physics Laboratory All Rights Reserved. Contact the JHU/APL Office of Technology Transfer for any additional rights.  www.jhuapl.edu/ott
% 
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
% 
%    http://www.apache.org/licenses/LICENSE-2.0
% 
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    % Kasthuri11 Defaults:
    % min_cluster_size = 15
    % template = vesicle_templates_kasthuri2.mat
    % min_cluster_size = 15
    % tail = .001
    % overlap_percentage = .25
    % cluster_dist_multiplier = 4;
    % cluster_cost = 80;
    % alpha = 1; % distance coef
    % beta = 51; % edge coef
    
    %% Check inputs
    if ~exist('em','var')
        error('vesicle_detect:param_error','You must provide a RAMONVolume to analyze');
    else
        if ~isa(em,'RAMONVolume')
            error('vesicle_detect:param_error','You must provide a RAMONVolume to analyze');
        end
    end
    
    if ~exist('template','var')
        error('vesicle_detect:param_error','You must provide a template generated by "get_template.m"');
    end
    
    if ~exist('min_cluster_size','var')
        min_cluster_size = 15;
    end
    if ~exist('tail','var')
        tail = .001;
    end
    if ~exist('overlap_percentage','var')
        overlap_percentage = .25;
    end
    
    
    if ~exist('cluster_dist_multiplier','var')
        cluster_dist_multiplier = 4;
    end
    if ~exist('cluster_cost','var')
        cluster_cost = 80;
    end
    if ~exist('alpha','var')
        alpha = 1;
    end
    if ~exist('beta','var')
        beta = 51;
    end
    
    
    %% Load Template
    load(template);
    
    %% Run Correlation
    matches = zeros(size(em.data));
    for ii = 1:size(em.data,3)
        [x,y,~] = size(em.data);
        C = zeros(x,y,size(patches,3)); %#ok<NODEF>
        for jj = 1:size(patches,3)
            W = ones(size(patches(:,:,jj)));
            W(1,:) = .7;
            W(end,:) = .7;
            W(:,1) = .7;
            W(:,end) = .7;
            C(:,:,jj) = wncc(double(em.data(:,:,ii)),double(patches(:,:,jj)),W);
        end
        
        C = sum(C,3);
        C(C<0) = 0;
        [counts,x] = hist(C(:),128);
        totals = cumsum(counts);
        percent = (totals(end) - totals) ./ totals(end);
        thresh_inds = find(percent < tail);
        
        threshImg = C;
        threshImg(threshImg <= x(thresh_inds(1))) = 0;
        threshImg(threshImg > x(thresh_inds(1))) = 1;
        if length(threshImg(threshImg ~=0)) > 3000
            error('vesicle_detect:bad_threshold','Check parameter "tail".  Too many labled points.');
        end
        matches(:,:,ii) = threshImg;
    end
    
    %% Cluster Slices
    vesicle_mask_size = floor(size(patches,1)/2);
    cluster_dist = vesicle_mask_size * cluster_dist_multiplier;
    
    matches_clustered = zeros(size(matches));
    for ss = 1:size(matches,3)  
        % Run edge detection
        gg = edge(double(em.data(:,:,ss)),'canny',[.15 .3],sqrt(3));
        
        % Dilate detects and remove data from gradient image
        se = strel('disk', vesicle_mask_size, 0);
        detections_dilated = imdilate(matches(:,:,ss),se,'same');
        gg(detections_dilated ~= 0) = 0;
        
        % Build graph based on edge weight based on distance/edge cost
        cc = bwconncomp(matches(:,:,ss));        
        cc_props = regionprops(cc,'Centroid');
        clear cc;
        centroids = struct2cell(cc_props);
        centroids = cell2mat(centroids');
        centroids = round(centroids);
        D = squareform(pdist(centroids));
        D(D > cluster_dist) = 0;
        inds = find(D ~= 0);
        edge_list = [];
        for ee = 1:length(inds)
            % Get coords
            [p1,p2] = ind2sub(size(D),inds(ee));
            
            % Get gradient points
            pnts = linepoints(centroids(p1,:),centroids(p2,:))';
            grad_inds = sub2ind(size(gg),pnts(:,2),pnts(:,1));
            edge_list = cat(1,edge_list,[p1,p2,D(inds(ee)) * alpha + sum(gg(grad_inds)) * beta]);
        end
        
        % If there aren't any vesicles on this slice move on
        if isempty(edge_list)
            continue;
        end
        
        % Trim costly edges
        cost = edge_list(:,3);
        inds_expensive = find(cost > cluster_cost);
        edge_list(inds_expensive,:) = []; %#ok<AGROW,FNDSB>
        clear cost
        
        % Agglomerate clusters
        clusters = zeros(length(centroids),length(centroids));
        label_source = 1;
        for ii = 1:size(edge_list,1)
            % Get Nodes of edge
            n = edge_list(ii,1:2);
            % Check for existing label
            existing_label = unique(cat(2,clusters(n(1),:),clusters(n(2),:)));
            if length(existing_label) == 1
                % Use label_source
                curr_label = label_source;
                label_source = label_source + 1;
            elseif length(existing_label) == 2
                % Using existing label
                curr_label = existing_label(2);
            elseif length(existing_label) == 3
                % Reconsile label merge
                curr_label = existing_label(2);
                clusters(clusters == existing_label(3)) = curr_label;
            else
                error('vesicle_detect:label_error','Too many labels exist for node.');
            end
            
            % Update cluster matrix
            clusters(n(1),n(2)) = curr_label;
            clusters(n(2),n(1)) = curr_label;
        end
        
        % Generate Clustered Slice
        slice_clustered = zeros(size(matches(:,:,1)));
        for ii = 1:length(centroids)
            id = unique(clusters(ii,:));
            if length(id) == 1
                % no cluster
                continue;
            elseif length(id) == 2
                slice_clustered(centroids(ii,2),centroids(ii,1)) = id(2);
            else
                error('vesicle_detect:label_error','Too many labels exist for node.');
            end
        end
                
        matches_clustered(:,:,ss) = slice_clustered;
        
        
        % TEMP Dilate and visualize
        %                 se = strel('disk', 3, 0);
        %                 slice_clustered_dilate = imdilate(slice_clustered,se,'same');
        %                 img = RAMONVolume(em.data(:,:,ss),eRAMONDataFormat.dense);
        %                 anno = RAMONVolume(slice_clustered_dilate,eRAMONDataFormat.dense);
        %                 h = image(img);
        %                 h.associate(anno);
        % TEMP Dilate and visualize
    end
    
    %% Relabel so slices do not repeat ids
    available_ids = 1:20000;
    for ii = 1:size(matches_clustered,3)
        temp = matches_clustered(:,:,ii);
        ids = unique(matches_clustered(:,:,ii));
        ids(1) = [];
        tf = ismember(ids,available_ids);
        for jj = 1:length(tf)
            if tf(jj) == 1
                available_ids(available_ids == ids(jj)) = [];
            else
                temp(temp == ids(jj)) = available_ids(1);
                available_ids(1) = [];
            end
        end
        
        matches_clustered(:,:,ii) = temp;
    end
    
    %% Link clusters in Z  
    
    % Make elipse images
    matches_regions = zeros(size(matches_clustered));    
    se = strel('disk', 15, 8);
    
    for ii = 1:size(matches_clustered,3)
        % dilates slices
        matches_regions(:,:,ii) =  imdilate(matches_clustered(:,:,ii),se,'same');       
    end
    
    % Compute overlap and if above threshold group
    for ii = 1:size(matches_clustered,3)-1
        slice_1 = matches_regions(:,:,ii);
        slice_2 = matches_regions(:,:,ii+1);         
        slice_1b = slice_1;
        slice_1b(slice_1b~=0) = 1;
        slice_2b = slice_2;
        slice_2b(slice_2b~=0) = 1;
        
        ids = unique(slice_1);
        ids(1) = [];
        for jj = 1:length(ids)
            slice_1_single = slice_1b;
            slice_1_single(slice_1 ~= ids(jj)) = 0;
            slice_1_single(slice_1 == ids(jj)) = 1;
            overlap = slice_1_single + slice_2b;
            inds = find(overlap > 1);
            
            if isempty(inds)
                continue;
            else
                label_1 = unique(slice_1(inds));
                label_2 = unique(slice_2(inds));
                for kk = 1:length(label_2)
                    % compute percent overlap and relabel slice 2
                    % entity if it meets criteria
                    label_inds = find(slice_2 == label_2(kk));
                    common_inds = intersect(label_inds, inds);
                    if length(common_inds)/length(label_inds) >= overlap_percentage
                        slice_2(slice_2 == label_2(kk)) = label_1;
                        matches_clustered(matches_clustered == label_2(kk)) = label_1;
                    end
                end
            end
        end
        
        matches_regions(:,:,ii+1) = slice_2;        
    end
    
    % Temp visualization
    %anno = RAMONVolume(matches_regions,eRAMONDataFormat.dense);
    % Temp visualization
    
    % Remove small clusters
    [counts,bins] = hist(matches_clustered(:),unique(matches_clustered));
    ids = bins(counts < min_cluster_size);
    for ii = 1:length(ids)
        matches_clustered(matches_clustered==ids(ii)) = 0;
    end
        
    se = strel('disk', 4, 0);
    matches_clustered_dilate = imdilate(matches_clustered,se,'same'); 
    labels = RAMONVolume(matches_clustered_dilate,eRAMONDataFormat.dense);
    labels.setXyzOffset(em.xyzOffset);
    labels.setResolution(em.resolution);
    
    % Temp visualization
%     img = RAMONVolume(em.data,eRAMONDataFormat.dense);
%     h = image(img);
%     h.associate(labels);
    % Temp visualization
    
end

